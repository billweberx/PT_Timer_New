package com.billweberx.pt_timer

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.focus.onFocusChanged
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalFocusManager
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import android.content.Context
import android.media.AudioAttributes
import android.media.SoundPool        // Import SoundPool
import androidx.compose.foundation.layout.*import androidx.compose.foundation.text.KeyboardActions
import android.media.AudioFocusRequest
import android.media.AudioManager
import android.media.ToneGenerator
import android.os.Build
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.runtime.getValue
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusDirection
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.TextRange
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.input.ImeAction
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.TextFieldValue
import kotlinx.coroutines.Job
import com.billweberx.pt_timer.ui.theme.PT_TimerTheme
import java.text.DecimalFormat
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.rememberScrollState
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.snapshots.SnapshotStateList
import androidx.compose.foundation.background
import androidx.compose.runtime.mutableStateListOf
import android.os.Handler
import android.os.Looper

//import androidx.compose.foundation.layout.weight
// Define AppTones here
object AppTones {
    const val COUNTDOWN_BEEP = ToneGenerator.TONE_PROP_BEEP
    const val PHASE_END_BEEP = ToneGenerator.TONE_CDMA_HIGH_L
    const val WORKOUT_COMPLETE_BEEP = ToneGenerator.TONE_CDMA_ALERT_CALL_GUARD

    // You can add more custom tones here if you wish, for example:
    // const val WARNING_SHORT_BEEP = ToneGenerator.TONE_CDMA_PIP
    // const val SUCCESS_BEEP = ToneGenerator.TONE_SUP_CONFIRM
}

// Updated Sound IDs based on your filenames
object AppSoundIds {
    var EXERCISE_START_SOUND_ID: Int = 0
    var EXERCISE_REST_SOUND_ID: Int = 0 // Changed from REST_START_SOUND_ID
    var EXERCISE_COMPLETE_SOUND_ID: Int = 0 // Changed from WORKOUT_COMPLETE_SOUND_ID
}

class MainActivity : ComponentActivity() {
    private var audioFocusRequest: AudioFocusRequest? = null
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val audioManager = getSystemService(Context.AUDIO_SERVICE) as AudioManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val playbackAttributes = AudioAttributes.Builder()
                .setUsage(AudioAttributes.USAGE_ALARM)
                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
                .build()
            audioFocusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT)
                .setAudioAttributes(playbackAttributes)
                .setAcceptsDelayedFocusGain(false)
                .setOnAudioFocusChangeListener { } // Consider handling focus changes
                .build()
            audioFocusRequest?.let { audioManager.requestAudioFocus(it) }
        } else {
            @Suppress("DEPRECATION")
            audioManager.requestAudioFocus(null, AudioManager.STREAM_ALARM, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT)
        }

        setContent {
            PT_TimerTheme {
                Surface(
                    modifier = Modifier.fillMaxSize()
                ) {
                    PTTimerScreen()
                }
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        val audioManager = getSystemService(Context.AUDIO_SERVICE) as AudioManager
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            audioFocusRequest?.let { audioManager.abandonAudioFocusRequest(it) }
        } else {
            @Suppress("DEPRECATION")
            audioManager.abandonAudioFocus(null)
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////
//fun playSound(
//    soundPool: SoundPool,
//    activeStreamIds: SnapshotStateList<Int>,
//    soundId: Int
//) {
//    // Stop all currently playing streams
//    activeStreamIds.forEach { streamId ->soundPool.stop(streamId) }
//    activeStreamIds.clear()
//
//    val streamId = soundPool.play(soundId, 1.0f, 1.0f, 1, 0, 1.0f)
//    if (streamId != 0) {
//        activeStreamIds.add(streamId)
//    }
//}
fun playSound(
    soundPool: SoundPool,
    activeStreamIds: SnapshotStateList<Int>,
    soundId: Int
) {
    activeStreamIds.forEach { streamId ->
        soundPool.stop(streamId)
    }
    activeStreamIds.clear()

    if (soundId != 0) {
        // Give SoundPool a brief moment to stop any current sound
        Handler(Looper.getMainLooper()).postDelayed({
            val streamId = soundPool.play(soundId, 1.0f, 1.0f, 1, 0, 1.0f)
            if (streamId != 0) {
                activeStreamIds.add(streamId)
            }
        }, 150) // 100ms delay before playing
    }
}


@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PTTimerScreen() {
    val context = LocalContext.current
    val sharedPreferences = context.getSharedPreferences(
        "PT_Timer_Prefs",
        Context.MODE_PRIVATE
    )
    val editor = sharedPreferences.edit()
    val focusManager = LocalFocusManager.current

    // --- Actual numeric states for timer logic ---
    var exerciseTime by remember {
        mutableStateOf(sharedPreferences.getString("exercise_time", "30.0")?.toDoubleOrNull() ?: 30.0)
    }
    var restTime by remember {
        mutableStateOf(sharedPreferences.getString("rest_time", "5.0")?.toDoubleOrNull() ?: 5.0)
    }
    var sets by remember {
        mutableStateOf(sharedPreferences.getString("sets", "3")?.toDoubleOrNull() ?: 3.0)
    }
    var totalTime by remember {
        mutableStateOf(sharedPreferences.getString("total_time", "0.0")?.toDoubleOrNull() ?: 0.0)
    }

    // --- SoundPool Setup ---
    val soundPool = remember {
        val audioAttributes = AudioAttributes.Builder()
            .setUsage(AudioAttributes.USAGE_ALARM)
            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION).build()
        SoundPool.Builder().setMaxStreams(3).setAudioAttributes(audioAttributes).build()
    }
    val activeStreamIds = remember { mutableStateListOf<Int>() }

    // --- TextFieldValue states for TextFields ---
    // Initialize with current numeric values, or empty if you prefer it not to show "0.0" for zero
    fun formatForTextField(value: Double, isInteger: Boolean = false): String {
        return if (value == 0.0 && isInteger) "0" // For sets, just "0"
        else if (value == 0.0 && !isInteger &&
            sharedPreferences.getString( // Check if pref was explicitly "0" vs "0.0"
                when {
                    value == exerciseTime -> "exercise_time"
                    value == restTime -> "rest_time"
                    else -> "total_time"
                }, null) == "0"
        ) "0"
        else if (isInteger) value.toInt().toString()
        else value.toString()
    }


    var exerciseTextFieldValue by remember {
        mutableStateOf(TextFieldValue(text = formatForTextField(exerciseTime)))
    }
    var restTextFieldValue by remember {
        mutableStateOf(TextFieldValue(text = formatForTextField(restTime)))
    }
    var setsTextFieldValue by remember {
        mutableStateOf(TextFieldValue(text = formatForTextField(sets, isInteger = true)))
    }
    var totalTimeTextFieldValue by remember {
        mutableStateOf(TextFieldValue(text = formatForTextField(totalTime)))
    }

    // --- Error states for TextFields ---
    var exerciseError by remember { mutableStateOf<String?>(null) }
    var restError by remember { mutableStateOf<String?>(null) }
    var setsError by remember { mutableStateOf<String?>(null) }
    var totalTimeError by remember { mutableStateOf<String?>(null) }
    val workoutCompleted = remember { mutableStateOf(false) }

    // --- Synchronization from numeric state back to TextFieldValue state ---
    // This is important if the numeric state can change from somewhere else (e.g. reset button)
    LaunchedEffect(exerciseTime) {
        val newText = formatForTextField(exerciseTime)
        if (newText != exerciseTextFieldValue.text) {
            exerciseTextFieldValue = exerciseTextFieldValue.copy(text = newText)
        }
    }
    LaunchedEffect(restTime) {
        val newText = formatForTextField(restTime)
        if (newText != restTextFieldValue.text) {
            restTextFieldValue = restTextFieldValue.copy(text = newText)
        }
    }
    LaunchedEffect(sets) {
        val newText = formatForTextField(sets, isInteger = true)
        if (newText != setsTextFieldValue.text) {
            setsTextFieldValue = setsTextFieldValue.copy(text = newText)
        }
    }
    LaunchedEffect(totalTime) {
        val newText = formatForTextField(totalTime)
        if (newText != totalTimeTextFieldValue.text) {
            totalTimeTextFieldValue = totalTimeTextFieldValue.copy(text = newText)
        }
    }


    LaunchedEffect(soundPool, context) {
        // Using updated filenames
        AppSoundIds.EXERCISE_START_SOUND_ID = soundPool.load(context, R.raw.exercise_start, 1)
        AppSoundIds.EXERCISE_REST_SOUND_ID = soundPool.load(context, R.raw.exercise_rest, 1)
        AppSoundIds.EXERCISE_COMPLETE_SOUND_ID = soundPool.load(context, R.raw.exercise_complete, 1)
    }

    DisposableEffect(Unit) { onDispose { soundPool.release() } }

     // --- Timer Coroutine and State (condensed for brevity, ensure your full logic is here) ---
    val coroutineScope = rememberCoroutineScope()
    var timerJob by remember { mutableStateOf<Job?>(null) }
    var timeLeftInCurrentPhaseMs by remember { mutableStateOf(0.0) }
    var overallElapsedTimeMs by remember { mutableStateOf(0.0) }
    var currentSetsRemaining by remember { mutableStateOf(0.0) }
    var isExercisePhase by remember { mutableStateOf(true) }
    var status by remember { mutableStateOf("Ready") }
    var isRunning by remember { mutableStateOf(false) }
    var isPaused by remember { mutableStateOf(false) }
    var calculatedInitialTotalWorkoutTimeMs by remember { mutableStateOf(0.0) }
    // ... other pause state variables ...

    // ADD THESE MISSING PAUSE-RELATED STATE VARIABLES:
    var pausedTimeLeftInCurrentPhaseMs by remember { mutableStateOf(0.0) }
    var pausedOverallElapsedTimeMs by remember { mutableStateOf(0.0) }
    var pausedIsExercisePhase by remember { mutableStateOf(true) }
    var pausedCurrentSetsRemaining by remember { mutableStateOf(0.0) }
    var pausedStatus by remember { mutableStateOf("") }
    var pausedCalculatedInitialTotalWorkoutTimeMs by remember { mutableStateOf(0.0) }






    val decimalFormat = remember { DecimalFormat("0.0") }
    val formattedTimeLeft = remember(timeLeftInCurrentPhaseMs) {
        // ... your formatting logic ...
        val totalSeconds = timeLeftInCurrentPhaseMs / 1000.0
        val minutes = (totalSeconds / 60).toInt()
        val seconds = totalSeconds % 60
        String.format("%02d:%s", minutes, decimalFormat.format(seconds))
    }

    // Ensure decimalFormat is defined before this, for example:
// val decimalFormat = remember { DecimalFormat("0.0") }
// Also ensure all dependencies for 'remember' (isRunning, isPaused, status, etc.) are available

    val remainingDisplay = remember(
        isRunning,
        isPaused,
        status, // The current status message (e.g., "Exercise Phase", "Paused", "Ready")
        currentSetsRemaining, // The number of sets currently left to do
        calculatedInitialTotalWorkoutTimeMs, // If using a total fixed workout time
        overallElapsedTimeMs, // How much time has passed in the entire workout
        totalTime // The user-configured total workout time (0 if not used)
    ) {
        // Logic to determine what string to display:
        when {
            !isRunning && !isPaused && status == "Ready" -> {
                "Configure and start"
            }
            status.startsWith("Workout Complete") || status.startsWith("Error:") -> {
                // If workout is done or there's an error,
                // you might want to show nothing here or a specific message.
                // For now, let's keep it clean or show the final status.
                // Or you could return the 'status' itself if it's descriptive enough
                "" // Or return status
            }
            isPaused -> {
                "Paused. " + if (totalTime > 0 && calculatedInitialTotalWorkoutTimeMs > 0) {
                    val remainingOverallSeconds = (calculatedInitialTotalWorkoutTimeMs - overallElapsedTimeMs).coerceAtLeast(0.0) / 1000.0
                    "Total time left: ${decimalFormat.format(remainingOverallSeconds)}s"
                } else if (sets > 0) {
                    "Sets left: ${currentSetsRemaining.toInt()}"
                } else {
                    "" // Should not happen if timer was properly configured
                }
            }
            isRunning -> { // If the timer is actively running
                if (totalTime > 0 && calculatedInitialTotalWorkoutTimeMs > 0) {
                    // Display remaining time based on total workout duration
                    val remainingOverallSeconds = (calculatedInitialTotalWorkoutTimeMs - overallElapsedTimeMs).coerceAtLeast(0.0) / 1000.0
                    "Total time left: ${decimalFormat.format(remainingOverallSeconds)}s"
                } else if (sets > 0) {
                    // Display remaining sets
                    "Sets left: ${currentSetsRemaining.toInt()}"
                } else {
                    // Fallback if neither total time nor sets are the primary mode (should be handled by timer logic)
                    "Running..."
                }
            }
            else -> {
                // Default or initial state before anything happens,
                // though "Ready" state above should cover it.
                "Awaiting action"
            }
        }
    }



    // --- Helper function to handle validation and state update on focus lost/action ---
    fun validateAndSave(
        textValue: String,
        isInteger: Boolean,
        minValue: Double = 0.0, // Minimum allowed value (e.g. >0 for exercise/sets)
        allowZero: Boolean = true, // For rest/total time, 0 is okay
        onError: (String?) -> Unit,
        onSuccess: (Double) -> Unit,
        prefKey: String
    ) {
        if (textValue.isBlank()) {
            if (!allowZero && minValue > 0) { // If blank not allowed for this field
                onError("Cannot be empty")
                // Optionally revert to the original numeric value or a default valid one.
                // For now, it will just show the error.
                return
            } else { // Blank is okay, treat as 0
                onError(null)
                onSuccess(0.0)
                editor.putString(prefKey, "0").apply()
                return
            }
        }

        val parsedValue = if (isInteger) textValue.toIntOrNull()?.toDouble() else textValue.toDoubleOrNull()

        if (parsedValue == null) {
            onError("Invalid number")
        } else if (parsedValue < minValue || (!allowZero && parsedValue == 0.0)) {
            onError(if (minValue > 0) "Must be > ${if (isInteger) minValue.toInt() else minValue}" else "Invalid value")
        } else {
            onError(null) // Clear error
            onSuccess(parsedValue)
            editor.putString(prefKey, textValue).apply() // Save the user's valid text
        }
    }


    // In PTTimerScreen

    // ... (state variables including pausedTimeLeftInCurrentPhaseMs, etc.) ...

    fun startTimer() {
        var hasError = false
        if (exerciseTime <= 0) { exerciseError = "Must be > 0"; hasError = true } else { exerciseError = null }
        if (sets <= 0) { setsError = "Must be > 0"; hasError = true } else { setsError = null }

        if (hasError) {
            status = "Fix errors before starting"
            return
        }
        // Clear all input errors if validation passed
        exerciseError = null; restError = null; setsError = null; totalTimeError = null

        if (isPaused) { // RESUMING
            // Restore the main timer state variables from their paused counterparts
            timeLeftInCurrentPhaseMs = pausedTimeLeftInCurrentPhaseMs
            overallElapsedTimeMs = pausedOverallElapsedTimeMs
            isExercisePhase = pausedIsExercisePhase
            currentSetsRemaining = pausedCurrentSetsRemaining
            calculatedInitialTotalWorkoutTimeMs = pausedCalculatedInitialTotalWorkoutTimeMs
            // status will be updated by coroutine's onPhaseChange
        } else { // STARTING FRESH
            isExercisePhase = true
            currentSetsRemaining = sets.toDouble()
            timeLeftInCurrentPhaseMs = exerciseTime * 1000
            overallElapsedTimeMs = 0.0
            calculatedInitialTotalWorkoutTimeMs = if (totalTime > 0) {
                totalTime * 1000
            } else {
                (exerciseTime * sets + restTime * (sets - 1).coerceAtLeast(0.0)) * 1000
            }
        }
        isPaused = false // Ensure not paused
        isRunning = true // This will trigger the LaunchedEffect
    }

    fun pauseTimer() {
        if (isRunning) {
            // Save current state for resume
            pausedTimeLeftInCurrentPhaseMs = timeLeftInCurrentPhaseMs
            pausedOverallElapsedTimeMs = overallElapsedTimeMs
            pausedIsExercisePhase = isExercisePhase
            pausedCurrentSetsRemaining = currentSetsRemaining
            pausedStatus = status // Save current status
            pausedCalculatedInitialTotalWorkoutTimeMs = calculatedInitialTotalWorkoutTimeMs

            isRunning = false // This will trigger the LaunchedEffect's else block to cancel the job
            isPaused = true
            status = "Paused. $pausedStatus" // Update status immediately
        }
    }

    fun stopTimer() {
        isRunning = false // Will cancel job via LaunchedEffect
        isPaused = false
        status = "Ready"
        // Reset timer values to initial config or zero
        timeLeftInCurrentPhaseMs = exerciseTime * 1000
        overallElapsedTimeMs = 0.0
        currentSetsRemaining = sets.toDouble()
        isExercisePhase = true
        // Clear paused state too
        pausedTimeLeftInCurrentPhaseMs = 0.0
        // ... reset other paused variables ...
    }


    LaunchedEffect(isRunning) { // Keyed only on isRunning
        if (isRunning) {
            // isPaused should be false here if logic is correct
            timerJob = coroutineScope.launch {
                timerCoroutine(
                    soundPool = soundPool,
                    activeStreamIds = activeStreamIds,
                    workoutCompleted = workoutCompleted,
                    // Pass the current state variables, which are set correctly by startTimer
                    initialTimeLeftInPhaseMs = timeLeftInCurrentPhaseMs,
                    initialOverallElapsedTimeMs = overallElapsedTimeMs,
                    initialIsExercisePhase = isExercisePhase,
                    initialSetsRemaining = currentSetsRemaining.toInt(), // Coroutine expects Int
                    exerciseDurationMs = exerciseTime * 1000,
                    restDurationMs = restTime * 1000,
                    totalWorkoutSets = sets.toInt(),
                    targetTotalWorkoutTimeMs = if (totalTime > 0) totalTime * 1000 else 0.0,
                    onUpdate = { newTimeLeft, newOverallElapsed, newIsExercise, newSetsLeft ->
                        timeLeftInCurrentPhaseMs = newTimeLeft
                        overallElapsedTimeMs = newOverallElapsed
                        isExercisePhase = newIsExercise
                        currentSetsRemaining = newSetsLeft.toDouble()
                    },
                    onPhaseChange = { newStatus ->
                        status = newStatus
                    },
                    onComplete = { finalStatus ->
                        status = finalStatus
                        isRunning = false // Critical to stop the timer state
                        isPaused = false
                        // Optionally call stopTimer() for a full reset to "Ready" and initial config times
                    }
                )
            }
        } else { // isRunning is false
            timerJob?.cancel()
        }
    }


    @Composable
    fun AutoSelectTextField(
        value: TextFieldValue,
        onValueChange: (TextFieldValue) -> Unit,
        label: String,
        isError: Boolean,
        onValidate: () -> Unit,
        modifier: Modifier = Modifier,
        readOnly: Boolean = false
    ) {
        var wasFocused by remember { mutableStateOf(false) }
        val isFocused = remember { mutableStateOf(false) }

        OutlinedTextField(
            value = value,
            onValueChange = onValueChange,
            label = { Text(label) },
            isError = isError,
            modifier = modifier
                .onFocusChanged { focusState ->
                    isFocused.value = focusState.isFocused
                    if (focusState.isFocused && !wasFocused) {
                        wasFocused = true // triggers LaunchedEffect below
                    } else if (!focusState.isFocused) {
                        wasFocused = false
                        onValidate()
                    }
                },
            readOnly = readOnly,
            singleLine = true
        )

        // âœ… Trigger selection after first focus
        LaunchedEffect(wasFocused) {
            if (wasFocused) {
                onValueChange(value.copy(selection = TextRange(0, value.text.length)))
            }
        }
    }



    Scaffold(topBar = { CenterAlignedTopAppBar(title = { Text("PT Interval Timer") }) }) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .verticalScroll(rememberScrollState()) // ðŸ‘ˆ Add this!
                .padding(paddingValues) // ðŸ‘ˆ This fixes the clipping
                .padding(8.dp),
            verticalArrangement = Arrangement.Top,
            horizontalAlignment = Alignment.CenterHorizontally
        ) {


            Column(
                modifier = Modifier
                    .fillMaxSize()
                 //   .background(Color.Red) // Debugging layout
                  //  .padding(paddingValues)
                    .padding(8.dp),
                horizontalAlignment = Alignment.CenterHorizontally,
                verticalArrangement = Arrangement.Top
            ) {
                Text(
                    formattedTimeLeft,
                    fontSize = 60.sp,
                    fontWeight = FontWeight.Bold,
                    color = if (isExercisePhase) Color(0xFF4CAF50) else Color(0xFF2196F3)
                )
                Text(status, fontSize = 24.sp, fontWeight = FontWeight.Medium)
                Text(remainingDisplay, fontSize = 18.sp)
                Spacer(modifier = Modifier.height(10.dp))

                // --- Exercise Time ---
//                var wasExerciseTimeFocused by remember{mutableStateOf(false)}
//                var wasRestTimeFocused by remember{mutableStateOf(false)}
//                var wasNumOfSetsFocused by remember{mutableStateOf(false)}
//                var wasTotalWorkoutTimeFocused by remember{mutableStateOf(false)}
//                var exerciseHasRequestSelection by remember{mutableStateOf(false)}
//                var restTimeHasRequestecSelection by remember{mutableStateOf(false)}
//                var numOfSetsHasRequestecSelection by remember{mutableStateOf(false)}
//                var totalWorkoutTimeHasRequestecSelection by remember{mutableStateOf(false)}



                AutoSelectTextField(
                    value = exerciseTextFieldValue,
                    onValueChange = { exerciseTextFieldValue = it },
                    label = "Exercise time (seconds)",
                    isError = exerciseError != null,
                    onValidate = {
                        validateAndSave(
                            exerciseTextFieldValue.text,
                            false,
                            0.01,
                            false,
                            { exerciseError = it },
                            { exerciseTime = it },
                            "exercise_time"
                        )
                    },
                    readOnly = isRunning || isPaused,
                    modifier = Modifier.fillMaxWidth()
                )

                AutoSelectTextField(
                    value = restTextFieldValue,
                    onValueChange = { restTextFieldValue = it },
                    label = "Rest time (seconds)",
                    isError = restError != null,
                    onValidate = {
                        validateAndSave(
                            restTextFieldValue.text,
                            false,
                            0.01,
                            false,
                            { restError = it },
                            { restTime = it },
                            "rest_time"
                        )
                    },
                    readOnly = isRunning || isPaused,
                    modifier = Modifier.fillMaxWidth()
                )



                /*
                OutlinedTextField(
                    value = exerciseTextFieldValue,
                    onValueChange = {
                        exerciseTextFieldValue = it; exerciseError = null
                    }, // Just update TextFieldValue
                    label = { Text("Exercise time (seconds)") },
                    isError = exerciseError != null,
                    supportingText = { if (exerciseError != null) Text(exerciseError!!) },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = KeyboardType.Decimal,
                        imeAction = ImeAction.Next
                    ),
                    keyboardActions = KeyboardActions(onNext = {
                        validateAndSave(
                            exerciseTextFieldValue.text, false, 0.01, false, // min > 0
                            { exerciseError = it }, { exerciseTime = it }, "exercise_time"
                        )
                        focusManager.moveFocus(FocusDirection.Down)
                    }),
                    modifier = Modifier
                        .fillMaxWidth()
                        .onFocusChanged { focusState ->
                            if (focusState.isFocused && !wasExerciseTimeFocused) {
                                wasExerciseTimeFocused = true
                                exerciseHasRequestSelection = false
                                exerciseTextFieldValue = exerciseTextFieldValue.copy(
                                    selection = TextRange(0, exerciseTextFieldValue.text.length)
                                )
                            } else if(!focusState.isFocused) { // Validate on focus lost
                                wasExerciseTimeFocused = false
                                exerciseHasRequestSelection = false
                                validateAndSave(
                                    exerciseTextFieldValue.text, false, 0.01, false,
                                    { exerciseError = it }, { exerciseTime = it }, "exercise_time"
                                )
                            }
                        },
                    readOnly = isRunning || isPaused, singleLine = true
                )
                if (wasExerciseTimeFocused && !exerciseHasRequestSelection) {
                    LaunchedEffect(Unit) {
                        onValueChange(
                            value.copy(selection = TextRange(0, value.text.length))
                        )
                        exerciseHasRequestSelection = true
                    }

*/

/*
                // --- Rest Time ---
                OutlinedTextField(
                    value = restTextFieldValue,
                    onValueChange = { restTextFieldValue = it; restError = null },
                    label = { Text("Rest time (seconds)") },
                    isError = restError != null,
                    supportingText = { if (restError != null) Text(restError!!) },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = KeyboardType.Decimal,
                        imeAction = ImeAction.Next
                    ),
                    keyboardActions = KeyboardActions(onNext = {
                        validateAndSave(
                            restTextFieldValue.text, false, 0.0, true, // allow 0
                            { restError = it }, { restTime = it }, "rest_time"
                        )
                        focusManager.moveFocus(FocusDirection.Down)
                    }),
                    modifier = Modifier
                        .fillMaxWidth()
                        .onFocusChanged { focusState ->
                            if (focusState.isFocused && !wasRestTimeFocused) {
                                restTextFieldValue = restTextFieldValue.copy(
                                    selection = TextRange(0, restTextFieldValue.text.length)
                                )
                            } else if(!focusState.isFocused) {
                                wasRestTimeFocused = false
                                validateAndSave(
                                    restTextFieldValue.text, false, 0.0, true,
                                    { restError = it }, { restTime = it }, "rest_time"
                                )
                            }
                        },
                    readOnly = isRunning || isPaused, singleLine = true
                )

                */

                AutoSelectTextField(
                    value = setsTextFieldValue,
                    onValueChange = { setsTextFieldValue = it },
                    label = "Number of sets",
                    isError = setsError != null,
                    onValidate = {
                        validateAndSave(
                            setsTextFieldValue.text,
                            false,
                            0.01,
                            false,
                            { setsError = it },
                            { sets = it },
                            "sets"
                        )
                    },
                    readOnly = isRunning || isPaused,
                    modifier = Modifier.fillMaxWidth()
                )


/*
                // --- Sets ---
                OutlinedTextField(
                    value = setsTextFieldValue,
                    onValueChange = { tfv -> // Only allow digits or be empty
                        val newText = tfv.text.filter { it.isDigit() }
                        setsTextFieldValue = tfv.copy(text = newText); setsError = null
                    },
                    label = { Text("Number of sets") },
                    isError = setsError != null,
                    supportingText = { if (setsError != null) Text(setsError!!) },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = KeyboardType.Number,
                        imeAction = ImeAction.Next
                    ),
                    keyboardActions = KeyboardActions(onNext = {
                        validateAndSave(
                            setsTextFieldValue.text, true, 1.0, false, // min 1
                            { setsError = it }, { sets = it }, "sets"
                        )
                        focusManager.moveFocus(FocusDirection.Down)
                    }),
                    modifier = Modifier
                        .fillMaxWidth()
                        .onFocusChanged { focusState ->
                            if (focusState.isFocused && !wasNumOfSetsFocused) {
                                wasNumOfSetsFocused = true
                                setsTextFieldValue = setsTextFieldValue.copy(
                                    selection = TextRange(0, setsTextFieldValue.text.length)
                                )
                            } else if(!focusState.isFocused) {
                                wasNumOfSetsFocused = false
                                validateAndSave(
                                    setsTextFieldValue.text, true, 1.0, false,
                                    { setsError = it }, { sets = it }, "sets"
                                )
                            }
                        },
                    readOnly = isRunning || isPaused, singleLine = true
                )
*/
                AutoSelectTextField(
                    value = totalTimeTextFieldValue,
                    onValueChange = { totalTimeTextFieldValue = it },
                    label = "Total workout time (sec, optional)",
                    isError = totalTimeError != null,
                    onValidate = {
                        validateAndSave(
                            totalTimeTextFieldValue.text,
                            false,
                            0.01,
                            false,
                            { totalTimeError = it },
                            { totalTime = it },
                            "sets"
                        )
                    },
                    readOnly = isRunning || isPaused,
                    modifier = Modifier.fillMaxWidth()
                )

   /*             // --- Total Time (Optional) ---
                OutlinedTextField(
                    value = totalTimeTextFieldValue,
                    onValueChange = { totalTimeTextFieldValue = it; totalTimeError = null },
                    label = { Text("Total workout time (sec, optional)") },
                    isError = totalTimeError != null,
                    supportingText = { if (totalTimeError != null) Text(totalTimeError!!) },
                    keyboardOptions = KeyboardOptions(
                        keyboardType = KeyboardType.Decimal,
                        imeAction = ImeAction.Done
                    ),
                    keyboardActions = KeyboardActions(onDone = {
                        validateAndSave(
                            totalTimeTextFieldValue.text, false, 0.0, true, // allow 0
                            { totalTimeError = it }, { totalTime = it }, "total_time"
                        )
                        focusManager.clearFocus()
                    }),
                    modifier = Modifier
                        .fillMaxWidth()
                        .onFocusChanged { focusState ->
                            if (focusState.isFocused && !wasTotalWorkoutTimeFocused) {
                                wasTotalWorkoutTimeFocused = true
                                totalTimeTextFieldValue = totalTimeTextFieldValue.copy(
                                    selection = TextRange(0, totalTimeTextFieldValue.text.length)
                                )
                            } else if(!focusState.isFocused){
                                wasTotalWorkoutTimeFocused = false
                                validateAndSave(
                                    totalTimeTextFieldValue.text, false, 0.0, true,
                                    { totalTimeError = it }, { totalTime = it }, "total_time"
                                )
                            }
                        },
                    readOnly = isRunning || isPaused, singleLine = true
                )
*/
            }

            Spacer(modifier = Modifier.height(16.dp))

            // --- Control Buttons ---
            Column( // This is the Column for your buttons
                modifier = Modifier.fillMaxWidth()
                    .padding(top = 16.dp), // Small gap between input boxes and buttons,
                // verticalArrangement = Arrangement.spacedBy(8.dp),
                horizontalAlignment = Alignment.CenterHorizontally // This centers the Buttons within this Column
            ) {
                //     Spacer(modifier = Modifier.weight(1f)) // Pushes buttons to the bottom

                // Button 1: Start / Stop
                Button(
                    onClick = {
                        focusManager.clearFocus()  // ðŸ‘ˆ This triggers onFocusChanged(false)
                        if (isRunning || isPaused) { // If it would show "Stop Timer"
                            stopTimer()
                        } else { // If it would show "Start Timer"
                            startTimer()
                        }
                     },
                    enabled = if (!isRunning && !isPaused) { // Conditions to enable "Start Timer"
                        exerciseTime > 0 && sets > 0
                    } else { // "Stop Timer" is always enabled when visible
                        true
                    },
                    modifier = Modifier
                        .fillMaxWidth() // Makes the button wide
                        .padding(horizontal = 48.dp, vertical = 4.dp) // Adjust padding as needed
                ) {
                    Text(if (isRunning || isPaused) "Stop Timer" else "Start Timer")
                }

                Spacer(modifier = Modifier.height(8.dp)) // Space between buttons

                // Button 2: Pause / Resume
                Button(
                    onClick = {
                        focusManager.clearFocus()  // ðŸ‘ˆ This triggers onFocusChanged(false)
                        if (isRunning && !isPaused) { // If it shows "Pause"
                            pauseTimer()
                        } else if (isPaused) { // If it shows "Resume"
                            workoutCompleted.value = false
                            startTimer() // startTimer handles resume logic
                        }
                        // No action if timer is fully stopped and this button might show "Pause" (but disabled)
                    },
                    enabled = isRunning || isPaused, // Enabled only if timer is active or paused
                    modifier = Modifier
                        .fillMaxWidth() // Makes the button wide
                        .padding(horizontal = 48.dp, vertical = 4.dp) // Adjust padding
                ) {
                    Text(
                        when {
                            isRunning && !isPaused -> "Pause"
                            isPaused -> "Resume"
                            else -> "Pause" // Shows "Pause" but will be disabled
                        }
                    )
                }
            } // This is the closing brace for the MAIN Column (the one that starts with .padding(paddingValues))
        }  // This is the closing brace for the parent Column
    } // This is the closing brace for Scaffold
} // This is the closing brace for PTTimerScreen()



// Remember to have your timerCoroutine function defined correctly.



/////////////////////////////////////////////////////////////////////////////////////
// Dummy timerCoroutine - REPLACE with your actual timer logic
// This version is designed to accept the current state and continue from there.
suspend fun timerCoroutine(
    soundPool: SoundPool, // Changed from toneGenerator to soundPool
    activeStreamIds : SnapshotStateList<Int>,
    workoutCompleted: MutableState<Boolean>,
    // Current state to start/resume from:
    initialTimeLeftInPhaseMs: Double,
    initialOverallElapsedTimeMs: Double,
    initialIsExercisePhase: Boolean,
    initialSetsRemaining: Int,
    // Original settings for workout structure:
    exerciseDurationMs: Double,
    restDurationMs: Double,
    totalWorkoutSets: Int,
    targetTotalWorkoutTimeMs: Double,// Callbacks:
    onUpdate: (timeLeftInPhaseMs: Double, overallElapsedTimeMs: Double, isExercisePhase: Boolean, setsRemaining: Int) -> Unit,
    onPhaseChange: (newStatus: String) -> Unit,
    onComplete: (finalStatus: String) -> Unit
) {
    var currentTimeLeftInPhaseMs = initialTimeLeftInPhaseMs
    var currentOverallElapsedTimeMs = initialOverallElapsedTimeMs
    var currentPhaseIsExercise = initialIsExercisePhase
    var setsLeft = initialSetsRemaining
    var workoutAlreadyCompleted = false // Flag to ensure onComplete and its sounds run only once
    val tickIntervalMs = 100L // Smallest unit of time progression for the timer



//    // Function to play sound (add this helper inside or outside timerCoroutine)
//    fun playSound(soundId: Int) {
//        currentStreamId?.let {
//            soundPool.stop(it) // Stop previous sound
//        }
//        if (soundId != 0) {
//            soundPool.play(soundId, 1.0f, 1.0f, 1, 0, 1.0f)
//        }
//    }

    val effectiveTotalWorkoutTimeMs = if (targetTotalWorkoutTimeMs > 0) {
        targetTotalWorkoutTimeMs
    } else {
        (exerciseDurationMs * totalWorkoutSets + restDurationMs * (totalWorkoutSets - 1).coerceAtLeast(0))
    }


    // --- Initial Phase Start ---
    if (!workoutAlreadyCompleted) { // Don't play start sound if resuming an already completed workout (edge case)
        if (currentPhaseIsExercise) {
            onPhaseChange("Exercise Phase")
            if (!workoutCompleted.value) {
                playSound(soundPool, activeStreamIds, AppSoundIds.EXERCISE_START_SOUND_ID)
            }
        } else {
            onPhaseChange("Rest Phase")
            if (!workoutCompleted.value) {
                playSound(soundPool, activeStreamIds, AppSoundIds.EXERCISE_REST_SOUND_ID)
            }
        }
    }

    // Initial checks
    if (setsLeft <= 0 && effectiveTotalWorkoutTimeMs <= 0) {
        if (!workoutAlreadyCompleted) {
            workoutAlreadyCompleted = true
            onComplete("Error: No sets or time specified")
        }
        return
    }
    if (setsLeft == 0 && totalWorkoutSets > 0 && effectiveTotalWorkoutTimeMs <= 0) {
        if (!workoutAlreadyCompleted) {
            workoutAlreadyCompleted = true
            onComplete("Workout Complete (Error: Started with 0 sets remaining)")
        }
        return
    }

    onPhaseChange(if (currentPhaseIsExercise) "Exercise Phase" else "Rest Phase")

    mainLoop@ while (true) {
        // --- Completion Checks (Primary location) ---
        if (!workoutAlreadyCompleted) {
            if (effectiveTotalWorkoutTimeMs > 0 && currentOverallElapsedTimeMs >= effectiveTotalWorkoutTimeMs) {
                workoutAlreadyCompleted = true
                onComplete("Workout Complete")
                workoutCompleted.value = true
                playSound(
                    soundPool,
                    activeStreamIds,
                    AppSoundIds.EXERCISE_COMPLETE_SOUND_ID
                ) // Play workout complete sound
                // If you want multiple distinct sounds for completion, you'd need separate loaded sounds
                // or play the same sound multiple times with delays:
                // repeat(3) { playSound(soundPool, currentStreamId, AppSoundIds.WORKOUT_COMPLETE_SOUND_ID); delay(500) }
                break@mainLoop
            }
            if (setsLeft <= 0 && totalWorkoutSets > 0 && effectiveTotalWorkoutTimeMs <= 0) { // Completed all sets
                workoutAlreadyCompleted = true
                onComplete("Workout Complete")
                workoutCompleted.value = true
                playSound(soundPool, activeStreamIds, AppSoundIds.EXERCISE_COMPLETE_SOUND_ID)
                break@mainLoop
            }
            if (setsLeft <= 0 && effectiveTotalWorkoutTimeMs <= 0) { // Catch-all for no sets left and no total time
                workoutAlreadyCompleted = true
                onComplete("Workout Complete")
                workoutCompleted.value = true
                playSound(soundPool, activeStreamIds, AppSoundIds.EXERCISE_COMPLETE_SOUND_ID)
                break@mainLoop
            }
        } else { // If already completed, break out of the loop
            break@mainLoop
        }
        // --- Core Timer Tick ---
        delay(tickIntervalMs)
        currentTimeLeftInPhaseMs -= tickIntervalMs
        currentOverallElapsedTimeMs += tickIntervalMs
        // --- Phase End Logic ---
        if (currentTimeLeftInPhaseMs <= 0) {
            currentTimeLeftInPhaseMs = 0.0 // Ensure it doesn't go negative for display
            onUpdate(currentTimeLeftInPhaseMs, currentOverallElapsedTimeMs, currentPhaseIsExercise, setsLeft) // Update UI before sound

            if (currentPhaseIsExercise) {
                // EXERCISE TIME EXPIRED
                setsLeft--

                // Check for immediate completion after set decrement
                if (!workoutAlreadyCompleted) {
                    if (setsLeft <= 0 && totalWorkoutSets > 0 && effectiveTotalWorkoutTimeMs <= 0) {
                        workoutAlreadyCompleted = true
                        onComplete("Workout Complete")
                        workoutCompleted.value = true
                        playSound(
                            soundPool,
                            activeStreamIds,
                            AppSoundIds.EXERCISE_COMPLETE_SOUND_ID
                        )
                        break@mainLoop
                    }
                } else { break@mainLoop }

                // Transition to Rest or next Exercise (if rest is 0)
                if (setsLeft > 0 || (effectiveTotalWorkoutTimeMs > 0 && currentOverallElapsedTimeMs < effectiveTotalWorkoutTimeMs)) {
                    currentPhaseIsExercise = false
                    if (restDurationMs > 0) {
                        currentTimeLeftInPhaseMs = restDurationMs
                        onPhaseChange("Rest Phase")
                        if((effectiveTotalWorkoutTimeMs - currentOverallElapsedTimeMs) > 0.1){
                            if (!workoutCompleted.value) {
                                playSound(
                                    soundPool,
                                    activeStreamIds,
                                    AppSoundIds.EXERCISE_REST_SOUND_ID
                                )
                            }
                        }// Play sound at START of Rest
                    } else { // Skip rest if duration is 0
                        // Effectively, rest phase is skipped, so immediately start next exercise
                        currentPhaseIsExercise = true
                        if (!workoutAlreadyCompleted && setsLeft <= 0 && effectiveTotalWorkoutTimeMs <= 0) { // Defensive check
                                workoutAlreadyCompleted = true
                                onComplete("Workout Complete")
                                break@mainLoop
                        } else {
                            break@mainLoop // Already completed
                        }
                        currentTimeLeftInPhaseMs = exerciseDurationMs
                        onPhaseChange("Exercise Phase")
                        if (!workoutCompleted.value) {
                            playSound(
                                soundPool,
                                activeStreamIds,
                                AppSoundIds.EXERCISE_START_SOUND_ID
                            ) // Play sound at START of Rest
                        }

                    }
                } else {  // Workout completed
                    if (!workoutAlreadyCompleted) {
                        workoutAlreadyCompleted = true
                        onComplete("Workout Complete")
                        workoutCompleted.value = true
                        playSound(
                            soundPool,
                            activeStreamIds,
                            AppSoundIds.EXERCISE_COMPLETE_SOUND_ID
                        )
                    }
                    break@mainLoop
                }
            } else { // Was Rest Phase, REST TIME EXPIRED
                // To play twice for rest end:
                // playSound(soundPool, currentStreamId, AppSoundIds.REST_END_SOUND_ID); delay(300); playSound(soundPool, currentStreamId, AppSoundIds.REST_END_SOUND_ID)
                currentPhaseIsExercise = true
                currentTimeLeftInPhaseMs = exerciseDurationMs
                onPhaseChange("Exercise Phase")
                if (!workoutCompleted.value) {
                    playSound(
                        soundPool,
                        activeStreamIds,
                        AppSoundIds.EXERCISE_START_SOUND_ID
                    ) // Play sound at START of Exercise
                }
            }

            // After any phase switch, re-check overall completion again as a final safeguard
            if (!workoutAlreadyCompleted) {
                if (effectiveTotalWorkoutTimeMs > 0 && currentOverallElapsedTimeMs >= effectiveTotalWorkoutTimeMs) {
                    workoutAlreadyCompleted = true
                    onComplete("Workout Complete")
                    workoutCompleted.value = true
                    playSound(
                        soundPool,
                        activeStreamIds,
                        AppSoundIds.EXERCISE_COMPLETE_SOUND_ID
                    ) // Play rest end sound
                    break@mainLoop
                }
                if (setsLeft <= 0 && totalWorkoutSets > 0 && effectiveTotalWorkoutTimeMs <= 0) {
                    workoutAlreadyCompleted = true
                    onComplete("Workout Complete")
                    workoutCompleted.value = true
                    playSound(
                        soundPool,
                        activeStreamIds,
                        AppSoundIds.EXERCISE_COMPLETE_SOUND_ID
                    ) // Play rest end sound
                    break@mainLoop
                }
            } else {
                break@mainLoop // Already completed
            }
        }

        // --- Update UI (call onUpdate at the end of each tick/iteration) ---
        // Ensure not to update if already broken from the loop due to completion
        if (workoutAlreadyCompleted) {
            break@mainLoop
        }
        onUpdate(currentTimeLeftInPhaseMs, currentOverallElapsedTimeMs, currentPhaseIsExercise, setsLeft)
    }
}
